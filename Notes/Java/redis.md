- 缓存
  - 优点
    - 降低后端负载
    - 直接内存中获取提高读写速度
  - 缺点
    - 数据一致性问题
    - 系统复杂度升高
  - 缓存更新策略
    - 更新策略
      - redis内存淘汰
      - 设置TTL
      - 手动更新(一致性最高)
    - 删除还是更新?
      - 更新:可能会产生无效写更新
      - 删除:更新数据库时直接删除缓存,下次查询重新获取
    - 如何保证缓存操作和数据库操作的原子性
      - 单体系统:单体事务
      - 分布式系统:分布式事务(TCC等)
    - 先删缓存还是更新数据库?
      - 先更新数据库后删除缓存
        - ![image-20230225154502351](C:\Users\77023\Desktop\MD笔记\MD\Notes\Java\images\image-20230225154502351.png)
        - 更新删除之前正好其它线程查询到了过期缓存,此时又去查询DB,正准备更新缓存的时候原来的线程更新并删除了缓存
      - 先删除缓存后更新数据库
        - ![image-20230225154425592](C:\Users\77023\Desktop\MD笔记\MD\Notes\Java\images\image-20230225154425592.png)
        - 删除后还未来得及更新DB有其他线程又将旧数据读出并再次缓存,造成不一致
    - 问题
      - 缓存穿透
        - 现象:Redis和DB均没有命中查询,导致缓存永远不生效
        - 原因:查询的数据不存在
        - 解决方案
          - 缓存空对象,并设定有效期
          - 布隆过滤器
          - 增强ID复杂度,进行规则校验,避免恶意攻击
      - 缓存击穿
        - 现象:高并发情况下多个线程Redis未命中热点数据,DB查询到重建缓存,且重建困难
        - 原因:高并发情况下多个线程Redis未命中,DB查询到重建缓存
        - 解决方案
          - 互斥锁
          - 逻辑过期时间
      - 缓存雪崩
        - 现象:同一时间大量Key失效或者redis宕机,大量请求到达数据库
        - 原因:设置了同样的过期时间,或者redis宕机
        - 解决方案
          - 给过期时间设定随机值
          - 集群高可用
          - 降级限流
          - 多级缓存
- 案例
  - 短信登录
    - 传统session
      - 直接将code和user信息保存到session中
      - 用户每次发送请求携带cookie中JsessionID获取信息
    - redis+token模式
      - 将code和user信息保存到redis中,生成token作为user信息的key
      - 返回token给前端,以后每次访问都携带token信息,然后通过拦截器使用token获取用户信息进行
    - jwt+token模式
      - 使用jwt给user信息加密,然后将结果作为token返回给浏览器,服务器每次通过token解析得到user信息
  - 登录token存储
  - 缓存